<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BalanCoffee - Automated E2E Tests</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 0; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            background: rgba(255,255,255,0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            text-align: center;
        }
        .test-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .test-panel {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            padding: 20px;
        }
        .app-panel {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            padding: 20px;
        }
        .scenario-list {
            max-height: 600px;
            overflow-y: auto;
        }
        .scenario {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            margin: 10px 0;
            overflow: hidden;
        }
        .scenario-header {
            background: #343a40;
            color: white;
            padding: 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .scenario-header:hover { background: #495057; }
        .scenario-body {
            padding: 15px;
            display: none;
        }
        .scenario-body.active { display: block; }
        .step {
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .step.pending { background: #fff3cd; color: #856404; }
        .step.running { background: #cce5ff; color: #004085; animation: pulse 1s infinite; }
        .step.success { background: #d4edda; color: #155724; }
        .step.failed { background: #f8d7da; color: #721c24; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .btn:hover { transform: translateY(-2px); }
        .btn-primary { background: #007bff; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-warning { background: #ffc107; color: black; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-secondary { background: #6c757d; color: white; }
        .iframe-container {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
        }
        .app-iframe {
            width: 100%;
            height: 600px;
            border: none;
        }
        .status-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
        }
        .status-ready { background: #28a745; color: white; }
        .status-running { background: #ffc107; color: black; }
        .status-error { background: #dc3545; color: white; }
        .logs {
            background: #1e1e1e;
            color: #f0f0f0;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 20px;
        }
        .log-entry { margin: 2px 0; }
        .log-error { color: #ff6b6b; }
        .log-success { color: #51cf66; }
        .log-warning { color: #ffd43b; }
        .log-info { color: #74c0fc; }
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #34ce57);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü§ñ BalanCoffee - Automated E2E Tests</h1>
            <p>Ki·ªÉm th·ª≠ t·ª± ƒë·ªông t·ª´ ƒë·∫ßu ƒë·∫øn cu·ªëi (End-to-End)</p>
            <div class="progress-bar">
                <div class="progress-fill" id="overall-progress"></div>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-primary" onclick="runAllScenarios()">üöÄ Ch·∫°y t·∫•t c·∫£</button>
            <button class="btn btn-success" onclick="runBasicFlow()">üìù Lu·ªìng c∆° b·∫£n</button>
            <button class="btn btn-warning" onclick="runOrderFlow()">üõí Lu·ªìng ƒë·∫∑t h√†ng</button>
            <button class="btn btn-danger" onclick="runAdminFlow()">üë®‚Äçüíº Lu·ªìng admin</button>
            <button class="btn btn-secondary" onclick="stopTests()">‚èπÔ∏è D·ª´ng</button>
            <button class="btn btn-secondary" onclick="resetTests()">üîÑ Reset</button>
        </div>

        <div class="test-grid">
            <div class="test-panel">
                <h3>üìã Test Scenarios</h3>
                <div class="scenario-list" id="scenario-list">
                    <!-- Scenarios will be populated here -->
                </div>
            </div>

            <div class="app-panel">
                <h3>üì± App Under Test</h3>
                <div class="iframe-container">
                    <div class="status-indicator status-ready" id="app-status">Ready</div>
                    <iframe src="index.html" class="app-iframe" id="app-iframe" title="BalanCoffee Test App"></iframe>
                </div>
            </div>
        </div>

        <div class="test-panel">
            <h3>üìù Test Logs</h3>
            <div class="logs" id="test-logs"></div>
        </div>
    </div>

    <script>
        class E2ETestRunner {
            constructor() {
                this.scenarios = [];
                this.currentScenario = null;
                this.isRunning = false;
                this.testResults = {
                    total: 0,
                    passed: 0,
                    failed: 0,
                    skipped: 0
                };
            }

            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logsContainer = document.getElementById('test-logs');
                
                const logDiv = document.createElement('div');
                logDiv.className = `log-entry log-${type}`;
                logDiv.textContent = `[${timestamp}] ${message}`;
                
                logsContainer.appendChild(logDiv);
                logsContainer.scrollTop = logsContainer.scrollHeight;
                
                console.log(`[${type.toUpperCase()}] ${message}`);
            }

            async waitForElement(selector, timeout = 8000) {
                const iframe = document.getElementById('app-iframe');
                const doc = iframe.contentDocument || iframe.contentWindow.document;
                
                return new Promise((resolve, reject) => {
                    const startTime = Date.now();
                    
                    const checkElement = () => {
                        const element = doc.querySelector(selector);
                        if (element) {
                            resolve(element);
                        } else if (Date.now() - startTime > timeout) {
                            reject(new Error(`Element ${selector} not found within ${timeout}ms`));
                        } else {
                            setTimeout(checkElement, 100);
                        }
                    };
                    
                    checkElement();
                });
            }

            async clickElement(selector) {
                try {
                    const element = await this.waitForElement(selector);
                    element.click();
                    await this.wait(300); // Wait for any animations
                    return true;
                } catch (error) {
                    this.log(`Failed to click ${selector}: ${error.message}`, 'error');
                    return false;
                }
            }

            async typeText(selector, text) {
                try {
                    const element = await this.waitForElement(selector);
                    element.value = text;
                    element.dispatchEvent(new Event('input', { bubbles: true }));
                    await this.wait(200);
                    return true;
                } catch (error) {
                    this.log(`Failed to type in ${selector}: ${error.message}`, 'error');
                    return false;
                }
            }

            async verifyElement(selector, expectedText = null) {
                try {
                    const element = await this.waitForElement(selector, 2000);
                    if (expectedText && !element.textContent.includes(expectedText)) {
                        throw new Error(`Element ${selector} does not contain "${expectedText}"`);
                    }
                    return true;
                } catch (error) {
                    this.log(`Verification failed for ${selector}: ${error.message}`, 'error');
                    return false;
                }
            }

            async wait(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }            async reloadApp() {
                try {
                    this.log('Reloading app iframe...', 'info');
                    const iframe = document.getElementById('app-iframe');
                    if (!iframe) {
                        throw new Error('Iframe not found');
                    }
                    
                    const originalSrc = iframe.src;
                    this.log(`Original src: ${originalSrc}`, 'info');
                    
                    iframe.src = 'about:blank';
                    await this.wait(100);
                    iframe.src = originalSrc;
                    await this.wait(3000); // Increased wait time for app to load
                    
                    // Check if the app loaded successfully
                    const doc = iframe.contentDocument || iframe.contentWindow.document;
                    if (!doc) {
                        throw new Error('Cannot access iframe document');
                    }
                    
                    // Check document ready state
                    if (doc.readyState !== 'complete') {
                        this.log(`Document state: ${doc.readyState}, waiting...`, 'warning');
                        await this.wait(2000);
                    }
                    
                    // Check for basic elements
                    const basicElements = doc.querySelector('.header') && doc.querySelector('#menu-grid');
                    if (!basicElements) {
                        throw new Error('Basic app elements not found after reload');
                    }
                    
                    this.log('App reloaded successfully', 'success');
                    return true;
                } catch (error) {
                    this.log(`Reload app failed: ${error.message}`, 'error');
                    throw error;
                }
            }

            async waitForModalToShow(modalId, timeout = 8000) {
                const iframe = document.getElementById('app-iframe');
                const doc = iframe.contentDocument || iframe.contentWindow.document;
                
                return new Promise((resolve, reject) => {
                    const startTime = Date.now();
                    
                    const checkModal = () => {
                        const modal = doc.getElementById(modalId);
                        if (modal && (modal.style.display !== 'none' && 
                            (modal.classList.contains('show') || 
                             modal.style.display === 'flex' || 
                             modal.style.display === 'block'))) {
                            resolve(modal);
                        } else if (Date.now() - startTime > timeout) {
                            reject(new Error(`Modal ${modalId} not shown within ${timeout}ms`));
                        } else {
                            setTimeout(checkModal, 100);
                        }
                    };
                    
                    checkModal();
                });
            }

            defineScenarios() {
                // Basic App Loading Scenario
                this.addScenario('App Loading & UI Verification', [
                    { name: 'T·∫£i l·∫°i ·ª©ng d·ª•ng', action: () => this.reloadApp() },
                    { name: 'Ki·ªÉm tra header', action: () => this.verifyElement('.header') },
                    { name: 'Ki·ªÉm tra menu grid', action: () => this.verifyElement('#menu-grid') },
                    { name: 'Ki·ªÉm tra sidebar', action: () => this.verifyElement('#sidebar') },
                    { name: 'Ki·ªÉm tra category buttons', action: () => this.verifyElement('.category-btn') },
                    { name: 'Ki·ªÉm tra admin button', action: () => this.verifyElement('button[onclick="toggleAdmin()"]') }
                ]);

                // Menu Navigation Scenario
                this.addScenario('Menu Navigation', [
                    { name: 'Click category "C√† ph√™ Vi·ªát"', action: () => this.clickElement('[data-category="cafe-viet"]') },
                    { name: 'Verify filtered menu', action: () => this.verifyElement('#menu-grid .menu-item') },
                    { name: 'Click category "T·∫•t c·∫£"', action: () => this.clickElement('[data-category="all"]') },
                    { name: 'Verify all items shown', action: () => this.verifyElement('#menu-grid .menu-item') }
                ]);                // Order Creation Scenario
                this.addScenario('Order Creation Flow', [
                    { name: 'T·∫°o h√≥a ƒë∆°n m·ªõi', action: () => this.clickElement('button[onclick="createNewInvoice()"]') },
                    { name: 'Verify order modal', action: () => this.waitForModalToShow('order-modal') },
                    { name: 'Add item to order', action: () => this.clickElement('.btn-add') },
                    { name: 'Verify item in order', action: () => this.verifyElement('#order-items .order-item') },
                    { name: 'Confirm order', action: () => this.clickElement('#confirm-order-btn') },
                    { name: 'Verify invoice created', action: () => this.verifyElement('#invoice-list .invoice-item') }
                ]);                // Payment Flow Scenario
                this.addScenario('Payment Flow', [
                    { name: 'Open existing invoice', action: () => this.clickElement('#invoice-list .invoice-item') },
                    { name: 'Proceed to payment', action: () => this.clickElement('#payment-btn') },
                    { name: 'Verify payment modal', action: () => this.waitForModalToShow('payment-modal') },
                    { name: 'Verify QR code', action: () => this.verifyElement('#qr-image') },
                    { name: 'Wait for payment buttons', action: () => this.wait(500) },
                    { name: 'Confirm payment', action: () => this.clickElement('button[onclick="confirmPayment()"]') },
                    { name: 'Verify success modal', action: () => this.waitForModalToShow('success-modal') },
                    { name: 'Close success modal', action: () => this.clickElement('#success-modal button') }
                ]);// Admin Flow Scenario
                this.addScenario('Admin Management', [
                    { name: 'Toggle admin mode', action: () => this.clickElement('button[onclick="toggleAdmin()"]') },
                    { name: 'Verify admin section', action: () => this.verifyElement('#admin-section') },
                    { name: 'Start new shift', action: () => this.clickElement('button[onclick="startNewShift()"]') },
                    { name: 'View current shift', action: () => this.clickElement('button[onclick="viewCurrentShift()"]') },
                    { name: 'End shift', action: () => this.clickElement('button[onclick="endShift()"]') },
                    { name: 'Verify end shift modal', action: () => this.waitForModalToShow('end-shift-modal') },
                    { name: 'Cancel end shift', action: () => this.clickElement('#end-shift-modal .btn-secondary') }
                ]);

                // Error Handling Scenario
                this.addScenario('Error Handling', [
                    { name: 'Try invalid actions', action: async () => {
                        // Try to delete non-existent invoice
                        const iframe = document.getElementById('app-iframe');
                        const win = iframe.contentWindow;
                        if (win.deleteInvoiceById) {
                            win.deleteInvoiceById('non-existent');
                        }
                        return true;
                    }},
                    { name: 'Check error notifications', action: () => this.verifyElement('.notification') },
                    { name: 'Clear error state', action: async () => {
                        await this.wait(3000); // Wait for notifications to clear
                        return true;
                    }}
                ]);

                // Performance Test Scenario
                this.addScenario('Performance Tests', [
                    { name: 'Measure app load time', action: async () => {
                        const startTime = performance.now();
                        await this.reloadApp();
                        const loadTime = performance.now() - startTime;
                        this.log(`App load time: ${loadTime.toFixed(2)}ms`, loadTime < 3000 ? 'success' : 'warning');
                        return loadTime < 5000; // Should load within 5 seconds
                    }},
                    { name: 'Test rapid clicking', action: async () => {
                        for (let i = 0; i < 5; i++) {
                            await this.clickElement('[data-category="cafe-viet"]');
                            await this.wait(100);
                            await this.clickElement('[data-category="all"]');
                            await this.wait(100);
                        }
                        return true;
                    }},
                    { name: 'Test memory usage', action: async () => {
                        const iframe = document.getElementById('app-iframe');
                        const win = iframe.contentWindow;
                        if (win.performance && win.performance.memory) {
                            const memory = win.performance.memory;
                            const usedMB = Math.round(memory.usedJSHeapSize / 1024 / 1024);
                            this.log(`Memory usage: ${usedMB}MB`, usedMB < 50 ? 'success' : 'warning');
                            return usedMB < 100; // Should use less than 100MB
                        }
                        return true;
                    }}
                ]);
            }

            addScenario(name, steps) {
                this.scenarios.push({
                    name,
                    steps: steps.map(step => ({ ...step, status: 'pending' })),
                    status: 'pending'
                });
            }

            createScenarioElement(scenario, index) {
                const scenarioDiv = document.createElement('div');
                scenarioDiv.className = 'scenario';
                scenarioDiv.innerHTML = `
                    <div class="scenario-header" onclick="toggleScenario(${index})">
                        <span>${scenario.name}</span>
                        <span class="status-badge" id="scenario-status-${index}">Pending</span>
                    </div>
                    <div class="scenario-body" id="scenario-body-${index}">
                        ${scenario.steps.map((step, stepIndex) => `
                            <div class="step pending" id="step-${index}-${stepIndex}">
                                <span>${step.name}</span>
                                <span class="step-status">‚è≥</span>
                            </div>
                        `).join('')}
                    </div>
                `;
                return scenarioDiv;
            }

            renderScenarios() {
                const container = document.getElementById('scenario-list');
                container.innerHTML = '';
                
                this.scenarios.forEach((scenario, index) => {
                    const element = this.createScenarioElement(scenario, index);
                    container.appendChild(element);
                });
            }

            async runScenario(scenarioIndex) {
                const scenario = this.scenarios[scenarioIndex];
                scenario.status = 'running';
                
                this.log(`üé¨ Running scenario: ${scenario.name}`, 'info');
                
                document.getElementById(`scenario-status-${scenarioIndex}`).textContent = 'Running';
                document.getElementById(`scenario-status-${scenarioIndex}`).style.background = '#ffc107';
                
                let allStepsPassed = true;
                
                for (let stepIndex = 0; stepIndex < scenario.steps.length; stepIndex++) {
                    if (!this.isRunning) break;
                    
                    const step = scenario.steps[stepIndex];
                    const stepElement = document.getElementById(`step-${scenarioIndex}-${stepIndex}`);
                    
                    step.status = 'running';
                    stepElement.className = 'step running';
                    stepElement.querySelector('.step-status').textContent = '‚ö°';
                    
                    this.log(`   ‚ñ∂Ô∏è ${step.name}`, 'info');
                    
                    try {
                        const result = await step.action();
                        
                        if (result) {
                            step.status = 'success';
                            stepElement.className = 'step success';
                            stepElement.querySelector('.step-status').textContent = '‚úÖ';
                            this.log(`   ‚úÖ ${step.name} - Success`, 'success');
                        } else {
                            step.status = 'failed';
                            stepElement.className = 'step failed';
                            stepElement.querySelector('.step-status').textContent = '‚ùå';
                            allStepsPassed = false;
                            this.log(`   ‚ùå ${step.name} - Failed`, 'error');
                        }
                    } catch (error) {
                        step.status = 'failed';
                        stepElement.className = 'step failed';
                        stepElement.querySelector('.step-status').textContent = '‚ùå';
                        allStepsPassed = false;
                        this.log(`   ‚ùå ${step.name} - Error: ${error.message}`, 'error');
                    }
                    
                    await this.wait(500); // Pause between steps
                }
                
                scenario.status = allStepsPassed ? 'success' : 'failed';
                const statusElement = document.getElementById(`scenario-status-${scenarioIndex}`);
                
                if (allStepsPassed) {
                    statusElement.textContent = 'Passed';
                    statusElement.style.background = '#28a745';
                    statusElement.style.color = 'white';
                    this.testResults.passed++;
                    this.log(`‚úÖ Scenario "${scenario.name}" passed`, 'success');
                } else {
                    statusElement.textContent = 'Failed';
                    statusElement.style.background = '#dc3545';
                    statusElement.style.color = 'white';
                    this.testResults.failed++;
                    this.log(`‚ùå Scenario "${scenario.name}" failed`, 'error');
                }
                
                this.updateProgress();
            }

            async runAllScenarios() {
                if (this.isRunning) {
                    this.log('Tests are already running', 'warning');
                    return;
                }
                
                this.isRunning = true;
                this.testResults = { total: this.scenarios.length, passed: 0, failed: 0, skipped: 0 };
                
                document.getElementById('app-status').textContent = 'Testing';
                document.getElementById('app-status').className = 'status-indicator status-running';
                
                this.log('üöÄ Starting all E2E test scenarios', 'info');
                
                for (let i = 0; i < this.scenarios.length; i++) {
                    if (!this.isRunning) break;
                    await this.runScenario(i);
                }
                
                this.isRunning = false;
                
                document.getElementById('app-status').textContent = 'Complete';
                document.getElementById('app-status').className = 'status-indicator status-ready';
                
                const summary = `Tests completed: ${this.testResults.passed}/${this.testResults.total} passed`;
                this.log(`üèÅ ${summary}`, this.testResults.failed === 0 ? 'success' : 'warning');
            }

            async runBasicFlow() {
                await this.runSpecificScenarios([0, 1]); // App Loading & Menu Navigation
            }

            async runOrderFlow() {
                await this.runSpecificScenarios([2, 3]); // Order Creation & Payment
            }

            async runAdminFlow() {
                await this.runSpecificScenarios([4]); // Admin Management
            }

            async runSpecificScenarios(indices) {
                if (this.isRunning) return;
                
                this.isRunning = true;
                this.testResults = { total: indices.length, passed: 0, failed: 0, skipped: 0 };
                
                for (const index of indices) {
                    if (!this.isRunning) break;
                    await this.runScenario(index);
                }
                
                this.isRunning = false;
            }

            stopTests() {
                this.isRunning = false;
                this.log('üõë Tests stopped by user', 'warning');
                
                document.getElementById('app-status').textContent = 'Stopped';
                document.getElementById('app-status').className = 'status-indicator status-error';
            }

            resetTests() {
                this.isRunning = false;
                this.scenarios.forEach(scenario => {
                    scenario.status = 'pending';
                    scenario.steps.forEach(step => step.status = 'pending');
                });
                
                this.testResults = { total: 0, passed: 0, failed: 0, skipped: 0 };
                this.renderScenarios();
                
                document.getElementById('test-logs').innerHTML = '';
                document.getElementById('overall-progress').style.width = '0%';
                document.getElementById('app-status').textContent = 'Ready';
                document.getElementById('app-status').className = 'status-indicator status-ready';
                
                this.log('üîÑ Tests reset', 'info');
            }

            updateProgress() {
                const total = this.scenarios.length;
                const completed = this.testResults.passed + this.testResults.failed;
                const progress = total > 0 ? (completed / total) * 100 : 0;
                
                document.getElementById('overall-progress').style.width = `${progress}%`;
            }
        }

        // Global test runner instance
        const testRunner = new E2ETestRunner();

        // Global functions for buttons
        function runAllScenarios() { testRunner.runAllScenarios(); }
        function runBasicFlow() { testRunner.runBasicFlow(); }
        function runOrderFlow() { testRunner.runOrderFlow(); }
        function runAdminFlow() { testRunner.runAdminFlow(); }
        function stopTests() { testRunner.stopTests(); }
        function resetTests() { testRunner.resetTests(); }

        function toggleScenario(index) {
            const body = document.getElementById(`scenario-body-${index}`);
            body.classList.toggle('active');
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            testRunner.defineScenarios();
            testRunner.renderScenarios();
            testRunner.log('ü§ñ E2E Test Runner initialized', 'success');
            testRunner.log(`üìã ${testRunner.scenarios.length} test scenarios loaded`, 'info');
        });
    </script>
</body>
</html>
